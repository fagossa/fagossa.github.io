---
layout: post
title:  "Common techniques with cats-effects"
categories: effects, scala, finally-tagless, io
---

# Cats-effect
The goal of this article is to document some _cats-effect_ techniques that could be helpful to start working with effets. The code is inspired on a talk made by *Paweł Szulc* at Scalapeño 2018 (originally based on _monix_).


## Our domain model
We are going to experiment with an application that will continuously request the temperature of a city, keep an inventory of forecasts and finally print the hottest city.

```scala
object domain {

  // the location of an imaginary external forecast service
  case class ForecastConfig(host: String, port: Int)

  sealed trait TempUnit extends Product with Serializable
  final case object Celcius extends TempUnit

  final case class Temperature(value: Int, unit: TempUnit = Celcius)

  final case class City(name: String)

  final case class Forecast(temperature: Temperature)

  // Our business errors
  sealed trait AppErrors extends NoStackTrace with Product with Serializable
  final case class UnknownCity(name: String) extends AppErrors

}
```

## Interacting with the console
As we are going to develop a console application we need a way to wrap thoses interactions with effects. The simplest behavior to read and write from the terminal can be expresed as:

```scala
trait Console[F[_]] {
  def printLn(line: String): F[Unit]
  def readLn: F[String]
}
```

Great! but actually how can we use this interface? Usually, this two alternatives come in mind:
* Add an _implicit_ parameter when needed, `def hello[F[_]](implicit C: Console[F])`
* Add bounds to `F`, for `Console`. Something like `def hello[F[_] : Console]` and then ask for the implementation with `implicitly`.

The former gets really verbose. The later requires an explicit `implicitly` every single time, `implicitly[Console[F]].printLn("hello")`. I personally prefer the later with a simple bonus: hide that _implicit_ call behind an `apply`, so the code gets cleaner:

```scala
object Console {
  def apply[F[_]: Console]: Console[F] = implicitly[Console[F]]
}

// no need to indicate the implicitly directly in the caller site
def hello[F[_] : Console] = Console[F].printLn("hello")
```

In case you are wondering...yes, somebody already did it for us on the internet: [console4cats](https://github.com/profunktor/console4cats). With this dependency we also get an interpreter for IO.


## Business logic

### The weather client
As we previously stated, we are going to give weather predictions for a given city. The actual call is out of the scope of this article, so lets provide a façade to an imaginary weather service.

```scala
trait WeatherClient[F[_]] {
  def forecast(city: City): F[Forecast]
}
object WeatherClient {
  def apply[F[_]: WeatherClient]: WeatherClient[F] = implicitly[WeatherClient[F]]
}
```

In order to build the weather client, we need to extract some values from the configuration. We could do this
* Using the MTL approach using an `ApplicativeAsk` which is basically a wrap around a _Read Monad_. However, our performance would be (severily) penalized.
* A much simpler approach is to specify the configuration as a parameter and then, extract the data as _effects_. This allow us to execute additional validations (if required).

```scala
def host[F[_]: Sync](config: ForecastConfig): F[String] = Sync[F].pure(config.host)

def port[F[_]: Sync](config: ForecastConfig): F[Int] = Sync[F].pure(config.port)
```

Now that we know how to extract the host and port, we have all the missing pieces to build an implementation of our weather client. The complete code for our weather client then becomes:

```scala
object LiveWeatherClient {
  // The host and port are not used, but you get the idea :)
  def make[F[_]: Sync](host: String, port: Int): F[WeatherClient[F]] =
    Sync[F].pure(new LiveWeatherClient[F](host, port))
}

final class LiveWeatherClient[F[_] : Sync] private(host: String, port: Int) extends WeatherClient[F] {
  override def forecast(city: City): F[Forecast] = Sync[F].pure {
    city match {
      case City("Paris") => Forecast(Temperature(28))
      case City("Lyon") => Forecast(Temperature(34))
      case _ => Forecast(Temperature(15))
    }
  }
}
```

Notice how our object has a smart constructor, `make` to build the actual implementation of the client. Also we want to hide the constructor of our interpreter to avoid leaking the state of our implementation.


### Handling state
The history of the requests is stored in a [Ref](https://typelevel.org/cats-effect/concurrency/ref.html). A `Ref` is basically an _Atomic Reference_ that can show itself as a _State Monad_. Here, we just get the current state, sort by temperature and get the first element.

```scala
type Requests = Map[City, Forecast]
import cats.effect.concurrent.Ref

def hottestCity[F[_]: Functor](
  ref: Ref[F, Requests]
): F[Option[(City, Temperature)]] = {
  import cats.syntax.functor._
  ref.get.map(reqs =>
    reqs.toList
      .sortBy(_._2.temperature.value)
      .map { case (city, forecast) => (city, forecast.temperature) }
      .reverse
      .headOption)
}
```

### Handling errors
To keep things simple I try to avoid _Monad Transformers_. In this particular case, we are going to use a `MonadError[F, E]` which is already provider by `Sync[F]`.

```scala
def cityByName[F[_]: Sync](name: String): F[City] = {
  import cats.syntax.applicative._
  name match {
    case "Paris" | "Lyon" => City(name).pure[F]
    case _ => Sync[F].raiseError(UnknownCity(name))
  }
}
```

We are assuming our `E` is a subtype of `Throwable`. If you are going that way, at least be sure to not to carry the stacktract with you:

```scala
sealed trait AppErrors extends NoStackTrace with Product with Serializable
```

### Handling interactions with the user
Asking for a city is basically printing a message and waiting for the user to type the city name.

```scala
def askCity[F[_]: Console: Sync]: F[City] = {
  import cats.syntax.functor._, cats.syntax.flatMap._
  for {
    _        <- Console[F].printLn("What is your next city?")
    cityName <- Console[F].readLn
    city     <- cityByName[F](cityName)
  } yield city
}
```


## Our application loop
The main loop consists of three main steps:
* ask for a new city
* request the forecast
* update the state
* determine the hottest city

The only actual remaining problem is how to get the interpreter for `WeatherClient[F]`. Usually we consider either a type constraint or a function parameter. Lets explore both options.

### Using type constraints
At first glance we could add `WeatherClient` as another bound, similar to what we did with `Sync` and `Console`.

```scala
def askLoop[F[_]: Sync: Console : WeatherClient](
  ref: Ref[F, Requests]
): F[Unit] = ???
```
However, in the caller site we need to provide an _implicit_ instance of `WeatherClient` within a for-comprehension. This is something impossible with standard scala (as far as I know). We would need to go with compiler plugins like [better-monadic-for](https://github.com/oleg-py/better-monadic-for).

```scala
for {
  h      <- host[F](config)
  p      <- port[F](config)
  implicit0(it: WeatherClient) <- LiveWeatherClient.make(h, p)
  ...
  _      <- askLoop[F](state).foreverM[Unit]
} yield ()
```

### Using a parameter
As the name implies, we just specify a new parameter constrained by `F`

```scala
def askLoop[F[_]: Sync: Console](
  weatherClient: WeatherClient[F],
  ref: Ref[F, Requests]
): F[Unit] = ???
```

And we only need to provide an instance using the `LiveWeatherClient.make(h, p)`. In my opinion this is the simplest alternative, and thus what we choose for this project.

```scala
import cats.effect.concurrent.Ref
def askLoop[F[_]: Sync: Console](
  weatherClient: WeatherClient[F],
  ref: Ref[F, Requests]
): F[Unit] = {
  import cats.syntax.functor._, cats.syntax.flatMap._
  for {
    _         <- Console[F].printLn(s"Start")
    city      <- askCity[F]
    forecast  <- weatherClient.forecast(city)
    _         <- Console[F].printLn(s"Forecast for $city is ${forecast.temperature}")
    _         <- ref.update(current => current + (city -> forecast))
    maybeCity <- hottestCity[F](ref)
    _ <- maybeCity match {
      case Some((city, temperature)) => Console[F].printLn(s"Hottest city found so far is $temperature in $city")
      case None => Console[F].printLn(s"No city yet")
    }
  } yield ()
}
```

### Composing everything
Our program builds the weather client, creates an initial state
and repeats the main loop forever.
```scala
def program[F[_]: Console: Sync](
  config: ForecastConfig
): F[Unit] = {
  import cats.syntax.functor._, cats.syntax.flatMap._
  for {
    h      <- host[F](config)
    p      <- port[F](config)
    client <- LiveWeatherClient.make(h, p)
    _      <- Console[F].printLn(s"Using weather service at http://$h:$p \n")
    state  <- Ref.of[F, Map[City, Forecast]](Map.empty[City, Forecast])
    _      <- askLoop[F](client, state).foreverM[Unit]
  } yield ()
}
```

### Running our application
Finally, to run our application we should call the program and provide an interpreter of _Console_ for _IO_.

```scala
object ForecastApp extends IOApp {
  // this is the interpreter for Console
  implicit val ioConsole: Console[IO] = new Console[IO] {
    override def printLn(line: String): IO[Unit] = IO.delay(println(line))
    override def readLn: IO[String] = IO.delay(scala.io.StdIn.readLine())
  }

  override def run(args: List[String]): IO[ExitCode] = {
    for {
      config <- IO.pure(domain.ForecastConfig("localhost", 8080))
      _      <- Logic.program[IO](config)
    } yield ExitCode.Success
  }
}
```

## Conclusions
TODO

## References
* Paweł Szulc made a talk on this topic with scalaZ https://www.youtube.com/watch?v=QM86Ab3lL20
