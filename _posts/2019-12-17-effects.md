---
layout: post
title:  "Common techniques with cats-effects"
categories: effects
---

# Cats-effect
The goal of this article is to document some _cats-effect_ techniques that could be helpful to start working with effets.


## Defining our domain model
We are going to experiment with an application that will request the temperature of a give city, keep the history of the requests and finally show the hottest city so far.

```scala
object domain {

  // the location of an imaginary external forecast service
  case class ForecastConfig(host: String, port: Int)


  sealed trait TempUnit extends Product with Serializable
  case object Celcius extends TempUnit

  case class Temperature(value: Int, unit: TempUnit = Celcius)

  case class City(name: String)

  case class Forecast(temperature: Temperature)

  // Our business errors
  sealed trait AppErrors extends NoStackTrace with Product with Serializable
  case class UnknownCity(name: String) extends AppErrors

}
```

## Writing to the console
As we are going to develop a console application we are going to need a way to
wrap thoses interactions with effects. The simplest behavior is  to
read and write from the terminal:

```scala
trait Console[F[_]] {
  def printLn(line: String): F[Unit]
  def readLn: F[String]
}
```

In order to use an implementation of this _trait_ we have two alternatives:
* Add an _implicit_ parameter, `def hello[F[_]](implicit C: Console[F])`
* Add bounds to `F[_]`, for example `def hello[F[_] : Console]`

The former gets really verbose and the later require an `implicitly` every single time: `implicitly[Console[F]].printLn("hello")`. I personally prefer the later with a simple bonus: hide that implicit call behind an `apply`:
```scala
object Console {
  def apply[F[_]: Console]: Console[F] = implicitly[Console[F]]
}
```
So,  every time we need to write to the console, we just use:
`Console[F]].printLn("hello")`.

Another alternative is to use [console4cats](https://github.com/profunktor/console4cats) that implements this for us.

## Business logic

### The weather client
The default implementation of our client has some hardcoded values.
Our _trait_ has only one method, that means that we can easilly transform our implementation into an _Single Abstract Method_ (SAM).

Notice how our companion object has smart constructors pour each implementation of the client.

```scala
trait WeatherClient[F[_]]{
  def forecast(city: City): F[Forecast]
}
object WeatherClient {
  def make[F[_]: Sync](host: String, port: Int): F[WeatherClient[F]] = Sync[F].pure {
    case City("Paris") => Sync[F].pure(Forecast(Temperature(28)))
    case City("Lyon") => Sync[F].pure(Forecast(Temperature(34)))
    case _ => Sync[F].pure(Forecast(Temperature(15)))
  }
}
```

In order to build the client, we need to extract certains values from the configuration. We could do this using the MTL approach with a `ApplicativeAsk` but our performance would be (severily) penalised. A much simpler approach is to specify the configuration as a parameter and then, extract the data as _effects_ (we could do some validations as required).

```scala
def host[F[_]: Sync](config: ForecastConfig): F[String] = Sync[F].pure(config.host)

def port[F[_]: Sync](config: ForecastConfig): F[Int] = Sync[F].pure(config.port)
```

### Handling state
The history of the requests is stored in a [Ref](https://typelevel.org/cats-effect/concurrency/ref.html). A `Ref` is basically a _thread safe_ container. Here, we just get the current state, sort by temperature and get the first element.

```scala
type Requests = Map[City, Forecast]
import cats.effect.concurrent.Ref

def hottestCity[F[_]: Functor](
  ref: Ref[F, Requests]
): F[Option[(City, Temperature)]] = {
  import cats.syntax.functor._
  ref.get.map(reqs =>
    reqs.toList
      .sortBy(_._2.temperature.value)
      .map {
        case (city, forcast) => (city, forcast.temperature)
      }
      .reverse
      .headOption)
}
```

### Handling interactions with the user
Demanding a city is basically printing a message and waiting for the used to type the city name

```scala
def askCity[F[_]: Console: Monad]: F[String] = {
  import cats.syntax.functor._, cats.syntax.flatMap._
  for {
    _        <- Console[F].printLn("What is your next city?")
    cityName <- Console[F].readLn
  } yield cityName
}
```

### Handling errors
When we want to avoid polluting all signatures with `Option[T]` or `Either[Error, T]`, we could use an implicit `MonadError[F]` which is already provider by `Sync[T]`.

```scala
def cityByName[F[_]: Sync](name: String): F[City] = {
  import cats.syntax.applicative._
  name match {
    case "Paris" | "Lyon" => City(name).pure[F]
    case _ => Sync[F].raiseError(UnknownCity(name))
  }
}
```

## Our application loop
The main loop consists of three main steps:
* ask for a new city
* update the state
* determine the hottest city

```scala
import cats.effect.concurrent.Ref
def askLoop[F[_]: Sync: Console](
  weatherClient: WeatherClient,
  ref: Ref[F, Requests]
): F[Unit] = {
  import cats.syntax.functor._, cats.syntax.flatMap._
  for {
    _         <- Console[F].printLn(s"Start")
    cityName  <- askCity[F]
    city      <- cityByName[F](cityName)
    forecast  <- weatherClient.forecast[F](city)
    _         <- Console[F].printLn(s"Forecast for $city is ${forecast.temperature}")
    _         <- ref.update(current => current + (city -> forecast))
    maybeCity <- hottestCity[F](ref)
    _ <- maybeCity match {
      case Some((city, temperature)) => Console[F].printLn(s"Hottest city found so far is $temperature in $city")
      case None => Console[F].printLn(s"No city yet")
    }
  } yield ()
}
```

### Composing everything
Our program builds the weather client, creates an initial state
and repeats the main loop forever.
```scala
def program[F[_]: Console: Sync](
  config: ForecastConfig
): F[Unit] = {
  import cats.syntax.functor._, cats.syntax.flatMap._
  for {
    h      <- host[F](config)
    p      <- port[F](config)
    client <- WeatherClient.make(h, p)
    _      <- Console[F].printLn(s"Using weather service at http://$h:$p \n")
    state  <- Ref.of[F, Map[City, Forecast]](Map.empty[City, Forecast])
    _      <- askLoop[F](client, state).foreverM[Unit]
  } yield ()
}
```

### Running our application
Finally, to run our application we should call the program and provide an
instance of _Console_ for _IO_.
```scala
object ForecastApp extends IOApp {
  implicit val ioConsole: Console[IO] = new Console[IO] {
    override def printLn(line: String): IO[Unit] = IO.delay(println(line))
    override def readLn: IO[String] = IO.delay(scala.io.StdIn.readLine())
  }

  override def run(args: List[String]): IO[ExitCode] = {
    for {
      config <- IO.pure(domain.ForecastConfig("localhost", 8080))
      _      <- Logic.program[IO](config)
    } yield ExitCode.Success
  }
}
```

## Conclusions
TODO

## References
* PaweÅ‚ Szulc made a talk on this topic with scalaZ https://www.youtube.com/watch?v=QM86Ab3lL20
